/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Payment scheme type
 */
export const Scheme = {
  Exact: "exact",
} as const;
/**
 * Payment scheme type
 */
export type Scheme = ClosedEnum<typeof Scheme>;

/**
 * Blockchain network for payment (client chooses)
 */
export const Network = {
  Base: "base",
  Solana: "solana",
} as const;
/**
 * Blockchain network for payment (client chooses)
 */
export type Network = ClosedEnum<typeof Network>;

/**
 * Request type
 */
export const Type = {
  Http: "http",
} as const;
/**
 * Request type
 */
export type Type = ClosedEnum<typeof Type>;

/**
 * HTTP method
 */
export const Method = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
  Patch: "PATCH",
} as const;
/**
 * HTTP method
 */
export type Method = ClosedEnum<typeof Method>;

/**
 * Body content type (for POST/PUT/PATCH)
 */
export const BodyType = {
  Json: "json",
  FormData: "form-data",
  MultipartFormData: "multipart-form-data",
  Text: "text",
  Binary: "binary",
} as const;
/**
 * Body content type (for POST/PUT/PATCH)
 */
export type BodyType = ClosedEnum<typeof BodyType>;

/**
 * Whether parameter is required
 */
export type RequiredT = boolean | Array<string>;

export type QueryParams = {
  /**
   * Parameter type
   */
  type?: string | undefined;
  /**
   * Whether parameter is required
   */
  required?: boolean | Array<string> | undefined;
  /**
   * Parameter description
   */
  description?: string | undefined;
  /**
   * Allowed values
   */
  enum?: Array<string> | undefined;
};

/**
 * Whether field is required
 */
export type X402PaymentMethodRequired = boolean | Array<string>;

/**
 * Nested object properties
 */
export type Properties = {};

export type BodyFields = {
  /**
   * Field type
   */
  type?: string | undefined;
  /**
   * Whether field is required
   */
  required?: boolean | Array<string> | undefined;
  /**
   * Field description
   */
  description?: string | undefined;
  /**
   * Nested object properties
   */
  properties?: Properties | undefined;
};

export type HeaderFields = {};

/**
 * HTTP request parameters
 */
export type Input = {
  /**
   * Request type
   */
  type: Type;
  /**
   * HTTP method
   */
  method: Method;
  /**
   * Body content type (for POST/PUT/PATCH)
   */
  bodyType?: BodyType | undefined;
  /**
   * Query parameter definitions
   */
  queryParams?: { [k: string]: QueryParams } | undefined;
  /**
   * Body field definitions (for POST/PUT/PATCH)
   */
  bodyFields?: { [k: string]: BodyFields } | undefined;
  /**
   * Custom header field definitions
   */
  headerFields?: { [k: string]: HeaderFields } | undefined;
};

/**
 * Schema describing the input and output format per x402scan specification.
 *
 * @remarks
 * Allows x402scan to present a UI for invoking resources from within the app.
 */
export type OutputSchema = {
  /**
   * HTTP request parameters
   */
  input?: Input | undefined;
  /**
   * Response structure definition
   */
  output?: { [k: string]: any } | undefined;
};

/**
 * Additional metadata
 */
export type Extra = {
  name?: string | undefined;
  version?: string | undefined;
};

/**
 * Details of an accepted payment method
 */
export type X402PaymentMethod = {
  /**
   * Payment scheme type
   */
  scheme: Scheme;
  /**
   * Blockchain network for payment (client chooses)
   */
  network: Network;
  /**
   * Maximum payment amount in token smallest unit (USDC has 6 decimals, so 100000 = 0.10 USDC)
   */
  maxAmountRequired: string;
  /**
   * Full URL of the resource being accessed
   */
  resource: string;
  /**
   * Human-readable payment description
   */
  description?: string | undefined;
  /**
   * MIME type of the resource
   */
  mimeType?: string | undefined;
  /**
   * Recipient wallet address (format depends on network)
   */
  payTo?: any | undefined;
  /**
   * Maximum time in seconds to complete payment
   */
  maxTimeoutSeconds?: number | undefined;
  /**
   * USDC token contract address (format depends on network)
   */
  asset?: any | undefined;
  /**
   * Schema describing the input and output format per x402scan specification.
   *
   * @remarks
   * Allows x402scan to present a UI for invoking resources from within the app.
   */
  outputSchema?: OutputSchema | undefined;
  /**
   * Additional metadata
   */
  extra?: Extra | undefined;
};

/** @internal */
export const Scheme$inboundSchema: z.ZodNativeEnum<typeof Scheme> = z
  .nativeEnum(Scheme);

/** @internal */
export const Scheme$outboundSchema: z.ZodNativeEnum<typeof Scheme> =
  Scheme$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Scheme$ {
  /** @deprecated use `Scheme$inboundSchema` instead. */
  export const inboundSchema = Scheme$inboundSchema;
  /** @deprecated use `Scheme$outboundSchema` instead. */
  export const outboundSchema = Scheme$outboundSchema;
}

/** @internal */
export const Network$inboundSchema: z.ZodNativeEnum<typeof Network> = z
  .nativeEnum(Network);

/** @internal */
export const Network$outboundSchema: z.ZodNativeEnum<typeof Network> =
  Network$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Network$ {
  /** @deprecated use `Network$inboundSchema` instead. */
  export const inboundSchema = Network$inboundSchema;
  /** @deprecated use `Network$outboundSchema` instead. */
  export const outboundSchema = Network$outboundSchema;
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const Method$inboundSchema: z.ZodNativeEnum<typeof Method> = z
  .nativeEnum(Method);

/** @internal */
export const Method$outboundSchema: z.ZodNativeEnum<typeof Method> =
  Method$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Method$ {
  /** @deprecated use `Method$inboundSchema` instead. */
  export const inboundSchema = Method$inboundSchema;
  /** @deprecated use `Method$outboundSchema` instead. */
  export const outboundSchema = Method$outboundSchema;
}

/** @internal */
export const BodyType$inboundSchema: z.ZodNativeEnum<typeof BodyType> = z
  .nativeEnum(BodyType);

/** @internal */
export const BodyType$outboundSchema: z.ZodNativeEnum<typeof BodyType> =
  BodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BodyType$ {
  /** @deprecated use `BodyType$inboundSchema` instead. */
  export const inboundSchema = BodyType$inboundSchema;
  /** @deprecated use `BodyType$outboundSchema` instead. */
  export const outboundSchema = BodyType$outboundSchema;
}

/** @internal */
export const RequiredT$inboundSchema: z.ZodType<
  RequiredT,
  z.ZodTypeDef,
  unknown
> = z.union([z.boolean(), z.array(z.string())]);

/** @internal */
export type RequiredT$Outbound = boolean | Array<string>;

/** @internal */
export const RequiredT$outboundSchema: z.ZodType<
  RequiredT$Outbound,
  z.ZodTypeDef,
  RequiredT
> = z.union([z.boolean(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequiredT$ {
  /** @deprecated use `RequiredT$inboundSchema` instead. */
  export const inboundSchema = RequiredT$inboundSchema;
  /** @deprecated use `RequiredT$outboundSchema` instead. */
  export const outboundSchema = RequiredT$outboundSchema;
  /** @deprecated use `RequiredT$Outbound` instead. */
  export type Outbound = RequiredT$Outbound;
}

export function requiredToJSON(requiredT: RequiredT): string {
  return JSON.stringify(RequiredT$outboundSchema.parse(requiredT));
}

export function requiredFromJSON(
  jsonString: string,
): SafeParseResult<RequiredT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequiredT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequiredT' from JSON`,
  );
}

/** @internal */
export const QueryParams$inboundSchema: z.ZodType<
  QueryParams,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().optional(),
  required: z.union([z.boolean(), z.array(z.string())]).optional(),
  description: z.string().optional(),
  enum: z.array(z.string()).optional(),
});

/** @internal */
export type QueryParams$Outbound = {
  type?: string | undefined;
  required?: boolean | Array<string> | undefined;
  description?: string | undefined;
  enum?: Array<string> | undefined;
};

/** @internal */
export const QueryParams$outboundSchema: z.ZodType<
  QueryParams$Outbound,
  z.ZodTypeDef,
  QueryParams
> = z.object({
  type: z.string().optional(),
  required: z.union([z.boolean(), z.array(z.string())]).optional(),
  description: z.string().optional(),
  enum: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryParams$ {
  /** @deprecated use `QueryParams$inboundSchema` instead. */
  export const inboundSchema = QueryParams$inboundSchema;
  /** @deprecated use `QueryParams$outboundSchema` instead. */
  export const outboundSchema = QueryParams$outboundSchema;
  /** @deprecated use `QueryParams$Outbound` instead. */
  export type Outbound = QueryParams$Outbound;
}

export function queryParamsToJSON(queryParams: QueryParams): string {
  return JSON.stringify(QueryParams$outboundSchema.parse(queryParams));
}

export function queryParamsFromJSON(
  jsonString: string,
): SafeParseResult<QueryParams, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryParams$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryParams' from JSON`,
  );
}

/** @internal */
export const X402PaymentMethodRequired$inboundSchema: z.ZodType<
  X402PaymentMethodRequired,
  z.ZodTypeDef,
  unknown
> = z.union([z.boolean(), z.array(z.string())]);

/** @internal */
export type X402PaymentMethodRequired$Outbound = boolean | Array<string>;

/** @internal */
export const X402PaymentMethodRequired$outboundSchema: z.ZodType<
  X402PaymentMethodRequired$Outbound,
  z.ZodTypeDef,
  X402PaymentMethodRequired
> = z.union([z.boolean(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace X402PaymentMethodRequired$ {
  /** @deprecated use `X402PaymentMethodRequired$inboundSchema` instead. */
  export const inboundSchema = X402PaymentMethodRequired$inboundSchema;
  /** @deprecated use `X402PaymentMethodRequired$outboundSchema` instead. */
  export const outboundSchema = X402PaymentMethodRequired$outboundSchema;
  /** @deprecated use `X402PaymentMethodRequired$Outbound` instead. */
  export type Outbound = X402PaymentMethodRequired$Outbound;
}

export function x402PaymentMethodRequiredToJSON(
  x402PaymentMethodRequired: X402PaymentMethodRequired,
): string {
  return JSON.stringify(
    X402PaymentMethodRequired$outboundSchema.parse(x402PaymentMethodRequired),
  );
}

export function x402PaymentMethodRequiredFromJSON(
  jsonString: string,
): SafeParseResult<X402PaymentMethodRequired, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => X402PaymentMethodRequired$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'X402PaymentMethodRequired' from JSON`,
  );
}

/** @internal */
export const Properties$inboundSchema: z.ZodType<
  Properties,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type Properties$Outbound = {};

/** @internal */
export const Properties$outboundSchema: z.ZodType<
  Properties$Outbound,
  z.ZodTypeDef,
  Properties
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Properties$ {
  /** @deprecated use `Properties$inboundSchema` instead. */
  export const inboundSchema = Properties$inboundSchema;
  /** @deprecated use `Properties$outboundSchema` instead. */
  export const outboundSchema = Properties$outboundSchema;
  /** @deprecated use `Properties$Outbound` instead. */
  export type Outbound = Properties$Outbound;
}

export function propertiesToJSON(properties: Properties): string {
  return JSON.stringify(Properties$outboundSchema.parse(properties));
}

export function propertiesFromJSON(
  jsonString: string,
): SafeParseResult<Properties, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Properties$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Properties' from JSON`,
  );
}

/** @internal */
export const BodyFields$inboundSchema: z.ZodType<
  BodyFields,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().optional(),
  required: z.union([z.boolean(), z.array(z.string())]).optional(),
  description: z.string().optional(),
  properties: z.lazy(() => Properties$inboundSchema).optional(),
});

/** @internal */
export type BodyFields$Outbound = {
  type?: string | undefined;
  required?: boolean | Array<string> | undefined;
  description?: string | undefined;
  properties?: Properties$Outbound | undefined;
};

/** @internal */
export const BodyFields$outboundSchema: z.ZodType<
  BodyFields$Outbound,
  z.ZodTypeDef,
  BodyFields
> = z.object({
  type: z.string().optional(),
  required: z.union([z.boolean(), z.array(z.string())]).optional(),
  description: z.string().optional(),
  properties: z.lazy(() => Properties$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BodyFields$ {
  /** @deprecated use `BodyFields$inboundSchema` instead. */
  export const inboundSchema = BodyFields$inboundSchema;
  /** @deprecated use `BodyFields$outboundSchema` instead. */
  export const outboundSchema = BodyFields$outboundSchema;
  /** @deprecated use `BodyFields$Outbound` instead. */
  export type Outbound = BodyFields$Outbound;
}

export function bodyFieldsToJSON(bodyFields: BodyFields): string {
  return JSON.stringify(BodyFields$outboundSchema.parse(bodyFields));
}

export function bodyFieldsFromJSON(
  jsonString: string,
): SafeParseResult<BodyFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BodyFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BodyFields' from JSON`,
  );
}

/** @internal */
export const HeaderFields$inboundSchema: z.ZodType<
  HeaderFields,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type HeaderFields$Outbound = {};

/** @internal */
export const HeaderFields$outboundSchema: z.ZodType<
  HeaderFields$Outbound,
  z.ZodTypeDef,
  HeaderFields
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HeaderFields$ {
  /** @deprecated use `HeaderFields$inboundSchema` instead. */
  export const inboundSchema = HeaderFields$inboundSchema;
  /** @deprecated use `HeaderFields$outboundSchema` instead. */
  export const outboundSchema = HeaderFields$outboundSchema;
  /** @deprecated use `HeaderFields$Outbound` instead. */
  export type Outbound = HeaderFields$Outbound;
}

export function headerFieldsToJSON(headerFields: HeaderFields): string {
  return JSON.stringify(HeaderFields$outboundSchema.parse(headerFields));
}

export function headerFieldsFromJSON(
  jsonString: string,
): SafeParseResult<HeaderFields, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HeaderFields$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HeaderFields' from JSON`,
  );
}

/** @internal */
export const Input$inboundSchema: z.ZodType<Input, z.ZodTypeDef, unknown> = z
  .object({
    type: Type$inboundSchema,
    method: Method$inboundSchema,
    bodyType: BodyType$inboundSchema.optional(),
    queryParams: z.record(z.lazy(() => QueryParams$inboundSchema)).optional(),
    bodyFields: z.record(z.lazy(() => BodyFields$inboundSchema)).optional(),
    headerFields: z.record(z.lazy(() => HeaderFields$inboundSchema)).optional(),
  });

/** @internal */
export type Input$Outbound = {
  type: string;
  method: string;
  bodyType?: string | undefined;
  queryParams?: { [k: string]: QueryParams$Outbound } | undefined;
  bodyFields?: { [k: string]: BodyFields$Outbound } | undefined;
  headerFields?: { [k: string]: HeaderFields$Outbound } | undefined;
};

/** @internal */
export const Input$outboundSchema: z.ZodType<
  Input$Outbound,
  z.ZodTypeDef,
  Input
> = z.object({
  type: Type$outboundSchema,
  method: Method$outboundSchema,
  bodyType: BodyType$outboundSchema.optional(),
  queryParams: z.record(z.lazy(() => QueryParams$outboundSchema)).optional(),
  bodyFields: z.record(z.lazy(() => BodyFields$outboundSchema)).optional(),
  headerFields: z.record(z.lazy(() => HeaderFields$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Input$ {
  /** @deprecated use `Input$inboundSchema` instead. */
  export const inboundSchema = Input$inboundSchema;
  /** @deprecated use `Input$outboundSchema` instead. */
  export const outboundSchema = Input$outboundSchema;
  /** @deprecated use `Input$Outbound` instead. */
  export type Outbound = Input$Outbound;
}

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

export function inputFromJSON(
  jsonString: string,
): SafeParseResult<Input, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Input$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Input' from JSON`,
  );
}

/** @internal */
export const OutputSchema$inboundSchema: z.ZodType<
  OutputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  input: z.lazy(() => Input$inboundSchema).optional(),
  output: z.record(z.any()).optional(),
});

/** @internal */
export type OutputSchema$Outbound = {
  input?: Input$Outbound | undefined;
  output?: { [k: string]: any } | undefined;
};

/** @internal */
export const OutputSchema$outboundSchema: z.ZodType<
  OutputSchema$Outbound,
  z.ZodTypeDef,
  OutputSchema
> = z.object({
  input: z.lazy(() => Input$outboundSchema).optional(),
  output: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputSchema$ {
  /** @deprecated use `OutputSchema$inboundSchema` instead. */
  export const inboundSchema = OutputSchema$inboundSchema;
  /** @deprecated use `OutputSchema$outboundSchema` instead. */
  export const outboundSchema = OutputSchema$outboundSchema;
  /** @deprecated use `OutputSchema$Outbound` instead. */
  export type Outbound = OutputSchema$Outbound;
}

export function outputSchemaToJSON(outputSchema: OutputSchema): string {
  return JSON.stringify(OutputSchema$outboundSchema.parse(outputSchema));
}

export function outputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<OutputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputSchema' from JSON`,
  );
}

/** @internal */
export const Extra$inboundSchema: z.ZodType<Extra, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string().optional(),
    version: z.string().optional(),
  });

/** @internal */
export type Extra$Outbound = {
  name?: string | undefined;
  version?: string | undefined;
};

/** @internal */
export const Extra$outboundSchema: z.ZodType<
  Extra$Outbound,
  z.ZodTypeDef,
  Extra
> = z.object({
  name: z.string().optional(),
  version: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Extra$ {
  /** @deprecated use `Extra$inboundSchema` instead. */
  export const inboundSchema = Extra$inboundSchema;
  /** @deprecated use `Extra$outboundSchema` instead. */
  export const outboundSchema = Extra$outboundSchema;
  /** @deprecated use `Extra$Outbound` instead. */
  export type Outbound = Extra$Outbound;
}

export function extraToJSON(extra: Extra): string {
  return JSON.stringify(Extra$outboundSchema.parse(extra));
}

export function extraFromJSON(
  jsonString: string,
): SafeParseResult<Extra, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Extra$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Extra' from JSON`,
  );
}

/** @internal */
export const X402PaymentMethod$inboundSchema: z.ZodType<
  X402PaymentMethod,
  z.ZodTypeDef,
  unknown
> = z.object({
  scheme: Scheme$inboundSchema,
  network: Network$inboundSchema,
  maxAmountRequired: z.string(),
  resource: z.string(),
  description: z.string().optional(),
  mimeType: z.string().optional(),
  payTo: z.any().optional(),
  maxTimeoutSeconds: z.number().int().optional(),
  asset: z.any().optional(),
  outputSchema: z.lazy(() => OutputSchema$inboundSchema).optional(),
  extra: z.lazy(() => Extra$inboundSchema).optional(),
});

/** @internal */
export type X402PaymentMethod$Outbound = {
  scheme: string;
  network: string;
  maxAmountRequired: string;
  resource: string;
  description?: string | undefined;
  mimeType?: string | undefined;
  payTo?: any | undefined;
  maxTimeoutSeconds?: number | undefined;
  asset?: any | undefined;
  outputSchema?: OutputSchema$Outbound | undefined;
  extra?: Extra$Outbound | undefined;
};

/** @internal */
export const X402PaymentMethod$outboundSchema: z.ZodType<
  X402PaymentMethod$Outbound,
  z.ZodTypeDef,
  X402PaymentMethod
> = z.object({
  scheme: Scheme$outboundSchema,
  network: Network$outboundSchema,
  maxAmountRequired: z.string(),
  resource: z.string(),
  description: z.string().optional(),
  mimeType: z.string().optional(),
  payTo: z.any().optional(),
  maxTimeoutSeconds: z.number().int().optional(),
  asset: z.any().optional(),
  outputSchema: z.lazy(() => OutputSchema$outboundSchema).optional(),
  extra: z.lazy(() => Extra$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace X402PaymentMethod$ {
  /** @deprecated use `X402PaymentMethod$inboundSchema` instead. */
  export const inboundSchema = X402PaymentMethod$inboundSchema;
  /** @deprecated use `X402PaymentMethod$outboundSchema` instead. */
  export const outboundSchema = X402PaymentMethod$outboundSchema;
  /** @deprecated use `X402PaymentMethod$Outbound` instead. */
  export type Outbound = X402PaymentMethod$Outbound;
}

export function x402PaymentMethodToJSON(
  x402PaymentMethod: X402PaymentMethod,
): string {
  return JSON.stringify(
    X402PaymentMethod$outboundSchema.parse(x402PaymentMethod),
  );
}

export function x402PaymentMethodFromJSON(
  jsonString: string,
): SafeParseResult<X402PaymentMethod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => X402PaymentMethod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'X402PaymentMethod' from JSON`,
  );
}
