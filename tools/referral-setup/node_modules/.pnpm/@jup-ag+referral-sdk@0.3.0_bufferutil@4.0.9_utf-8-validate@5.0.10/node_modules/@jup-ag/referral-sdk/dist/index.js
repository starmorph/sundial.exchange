"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/referral.ts
var _anchor = require('@coral-xyz/anchor');







var _spltoken = require('@solana/spl-token');







var _web3js = require('@solana/web3.js');
var _chunk = require('lodash/chunk'); var _chunk2 = _interopRequireDefault(_chunk);

// src/chunks.ts
function chunks(array, size) {
  return Array.apply(0, new Array(Math.ceil(array.length / size))).map(
    (_, index) => array.slice(index * size, (index + 1) * size)
  );
}
function chunkedGetMultipleAccountInfos(connection, pks, chunkSize = 100) {
  return __async(this, null, function* () {
    return (yield Promise.all(
      chunks(pks, chunkSize).map(
        (chunk2) => connection.getMultipleAccountsInfo(chunk2)
      )
    )).flat();
  });
}

// src/constant.ts

var PROGRAM_ID = new (0, _web3js.PublicKey)(
  "REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3"
);
var RPC_URL = process.env.RPC_URL || process.env.NEXT_PUBLIC_RPC_URL || _web3js.clusterApiUrl.call(void 0, "mainnet-beta");

// src/FeeService.ts







var FeeServiceImpl = class {
  constructor() {
    // --------------------
    // API
    // --------------------
    this.getMarketReferenceFee = () => __async(this, null, function* () {
      const data = (yield fetch("https://cache.jup.ag/reference-fees")).json();
      return data;
    });
    // --------------------
    // Helper methods
    // --------------------
    /**
     *
     * Code snippets from the Solana documentation
     * @see https://solana.com/developers/guides/advanced/how-to-request-optimal-compute#how-to-request-compute-budget
     */
    this.getSimulationUnits = (payload) => __async(this, null, function* () {
      const { instructions, payer, lookupTables } = payload;
      const testInstructions = [
        _web3js.ComputeBudgetProgram.setComputeUnitLimit({ units: 14e5 }),
        ...instructions
      ];
      const testVersionedTxn = new (0, _web3js.VersionedTransaction)(
        new (0, _web3js.TransactionMessage)({
          instructions: testInstructions,
          payerKey: payer,
          recentBlockhash: _web3js.PublicKey.default.toString()
        }).compileToV0Message(lookupTables)
      );
      const simulation = yield this.connection.simulateTransaction(
        testVersionedTxn,
        {
          replaceRecentBlockhash: true,
          sigVerify: false
        }
      );
      if (simulation.value.err) {
        return void 0;
      }
      return simulation.value.unitsConsumed;
    });
    this.addMarginErrorForComputeUnitLimit = (units, margin) => Math.floor(units * margin);
    this.getReferralReferenceFeeInMicroLamports = () => __async(this, null, function* () {
      const marketReferenceFeeInLamports = yield this.getMarketReferenceFee();
      return marketReferenceFeeInLamports.referral;
    });
    // --------------------
    // Main methods
    // --------------------
    this.getOptimalComputeUnitLimitAndPrice = (payload) => __async(this, null, function* () {
      const simulationUnits = yield this.getSimulationUnits(payload);
      const simulationUnitsWithMarginError = this.addMarginErrorForComputeUnitLimit(simulationUnits, 1.2);
      const referenceFeeInMicroLamports = yield this.getReferralReferenceFeeInMicroLamports();
      return {
        // `computeUnitLimit`
        units: simulationUnitsWithMarginError,
        // `computeUnitPrice`
        microLamports: referenceFeeInMicroLamports
      };
    });
    this.connection = new (0, _web3js.Connection)(RPC_URL);
  }
};
var feeService = new FeeServiceImpl();

// src/idl.ts
var IDL = {
  version: "0.1.0",
  name: "referral",
  instructions: [
    {
      name: "initializeProject",
      accounts: [
        {
          name: "payer",
          isMut: true,
          isSigner: true
        },
        {
          name: "base",
          isMut: false,
          isSigner: true
        },
        {
          name: "admin",
          isMut: false,
          isSigner: false
        },
        {
          name: "project",
          isMut: true,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "InitializeProjectParams"
          }
        }
      ]
    },
    {
      name: "initializeReferralAccount",
      accounts: [
        {
          name: "payer",
          isMut: true,
          isSigner: true
        },
        {
          name: "partner",
          isMut: false,
          isSigner: false
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: true,
          isSigner: true
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "InitializeReferralAccountParams"
          }
        }
      ]
    },
    {
      name: "initializeReferralAccountWithName",
      accounts: [
        {
          name: "payer",
          isMut: true,
          isSigner: true
        },
        {
          name: "partner",
          isMut: false,
          isSigner: false
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "InitializeReferralAccountWithNameParams"
          }
        }
      ]
    },
    {
      name: "updateProject",
      accounts: [
        {
          name: "admin",
          isMut: false,
          isSigner: true
        },
        {
          name: "project",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "UpdateProjectParams"
          }
        }
      ]
    },
    {
      name: "transferProject",
      accounts: [
        {
          name: "admin",
          isMut: false,
          isSigner: true
        },
        {
          name: "newAdmin",
          isMut: false,
          isSigner: false
        },
        {
          name: "project",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "TransferProjectParams"
          }
        }
      ]
    },
    {
      name: "updateReferralAccount",
      accounts: [
        {
          name: "admin",
          isMut: false,
          isSigner: true
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "UpdateReferralAccountParams"
          }
        }
      ]
    },
    {
      name: "transferReferralAccount",
      accounts: [
        {
          name: "partner",
          isMut: false,
          isSigner: true
        },
        {
          name: "newPartner",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: true,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "TransferReferralAccountParams"
          }
        }
      ]
    },
    {
      name: "initializeReferralTokenAccount",
      accounts: [
        {
          name: "payer",
          isMut: true,
          isSigner: true
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "mint",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "claim",
      accounts: [
        {
          name: "payer",
          isMut: true,
          isSigner: true
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "admin",
          isMut: false,
          isSigner: false
        },
        {
          name: "projectAdminTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "partner",
          isMut: false,
          isSigner: false
        },
        {
          name: "partnerTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "mint",
          isMut: false,
          isSigner: false
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "createAdminTokenAccount",
      accounts: [
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "projectAuthority",
          isMut: true,
          isSigner: false
        },
        {
          name: "admin",
          isMut: false,
          isSigner: false
        },
        {
          name: "projectAdminTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "mint",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "withdrawFromProject",
      accounts: [
        {
          name: "admin",
          isMut: true,
          isSigner: true
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "projectAuthority",
          isMut: true,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: [
        {
          name: "params",
          type: {
            defined: "WithdrawFromProjectParams"
          }
        }
      ]
    },
    {
      name: "claimV2",
      accounts: [
        {
          name: "payer",
          isMut: true,
          isSigner: true
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "admin",
          isMut: false,
          isSigner: false
        },
        {
          name: "projectAdminTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "partner",
          isMut: false,
          isSigner: false
        },
        {
          name: "partnerTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "mint",
          isMut: false,
          isSigner: false
        },
        {
          name: "systemProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    },
    {
      name: "closeReferralTokenAccountV2",
      accounts: [
        {
          name: "admin",
          isMut: true,
          isSigner: true
        },
        {
          name: "project",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralAccount",
          isMut: false,
          isSigner: false
        },
        {
          name: "referralTokenAccount",
          isMut: true,
          isSigner: false
        },
        {
          name: "partner",
          isMut: true,
          isSigner: false
        },
        {
          name: "mint",
          isMut: false,
          isSigner: false
        },
        {
          name: "tokenProgram",
          isMut: false,
          isSigner: false
        },
        {
          name: "associatedTokenProgram",
          isMut: false,
          isSigner: false
        }
      ],
      args: []
    }
  ],
  accounts: [
    {
      name: "project",
      type: {
        kind: "struct",
        fields: [
          {
            name: "base",
            type: "publicKey"
          },
          {
            name: "admin",
            type: "publicKey"
          },
          {
            name: "name",
            type: "string"
          },
          {
            name: "defaultShareBps",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "referralAccount",
      type: {
        kind: "struct",
        fields: [
          {
            name: "partner",
            type: "publicKey"
          },
          {
            name: "project",
            type: "publicKey"
          },
          {
            name: "shareBps",
            type: "u16"
          },
          {
            name: "name",
            type: {
              option: "string"
            }
          }
        ]
      }
    }
  ],
  types: [
    {
      name: "InitializeProjectParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "name",
            type: "string"
          },
          {
            name: "defaultShareBps",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "InitializeReferralAccountWithNameParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "name",
            type: "string"
          }
        ]
      }
    },
    {
      name: "InitializeReferralAccountParams",
      type: {
        kind: "struct",
        fields: []
      }
    },
    {
      name: "TransferProjectParams",
      type: {
        kind: "struct",
        fields: []
      }
    },
    {
      name: "TransferReferralAccountParams",
      type: {
        kind: "struct",
        fields: []
      }
    },
    {
      name: "UpdateProjectParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "name",
            type: {
              option: "string"
            }
          },
          {
            name: "defaultShareBps",
            type: {
              option: "u16"
            }
          }
        ]
      }
    },
    {
      name: "UpdateReferralAccountParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "shareBps",
            type: "u16"
          }
        ]
      }
    },
    {
      name: "WithdrawFromProjectParams",
      type: {
        kind: "struct",
        fields: [
          {
            name: "amount",
            type: "u64"
          }
        ]
      }
    }
  ],
  events: [
    {
      name: "InitializeProjectEvent",
      fields: [
        {
          name: "project",
          type: "publicKey",
          index: false
        },
        {
          name: "admin",
          type: "publicKey",
          index: false
        },
        {
          name: "name",
          type: "string",
          index: false
        },
        {
          name: "defaultShareBps",
          type: "u16",
          index: false
        }
      ]
    },
    {
      name: "UpdateProjectEvent",
      fields: [
        {
          name: "project",
          type: "publicKey",
          index: false
        },
        {
          name: "name",
          type: "string",
          index: false
        },
        {
          name: "defaultShareBps",
          type: "u16",
          index: false
        }
      ]
    },
    {
      name: "InitializeReferralAccountEvent",
      fields: [
        {
          name: "project",
          type: "publicKey",
          index: false
        },
        {
          name: "partner",
          type: "publicKey",
          index: false
        },
        {
          name: "referralAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "shareBps",
          type: "u16",
          index: false
        },
        {
          name: "name",
          type: {
            option: "string"
          },
          index: false
        }
      ]
    },
    {
      name: "UpdateReferralAccountEvent",
      fields: [
        {
          name: "referralAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "shareBps",
          type: "u16",
          index: false
        }
      ]
    },
    {
      name: "InitializeReferralTokenAccountEvent",
      fields: [
        {
          name: "project",
          type: "publicKey",
          index: false
        },
        {
          name: "referralAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "referralTokenAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        }
      ]
    },
    {
      name: "ClaimEvent",
      fields: [
        {
          name: "project",
          type: "publicKey",
          index: false
        },
        {
          name: "projectAdminTokenAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "referralAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "referralTokenAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "partnerTokenAccount",
          type: "publicKey",
          index: false
        },
        {
          name: "mint",
          type: "publicKey",
          index: false
        },
        {
          name: "referralAmount",
          type: "u64",
          index: false
        },
        {
          name: "projectAmount",
          type: "u64",
          index: false
        }
      ]
    }
  ],
  errors: [
    {
      code: 6e3,
      name: "InvalidCalculation"
    },
    {
      code: 6001,
      name: "InvalidSharePercentage"
    },
    {
      code: 6002,
      name: "NameTooLong"
    }
  ]
};

// src/utils.ts





var getOrCreateATAInstruction = (_0, _1, _2, ..._3) => __async(void 0, [_0, _1, _2, ..._3], function* (tokenMint, owner, connection, payer = owner, allowOwnerOffCurve = true, tokenProgram = _spltoken.TOKEN_PROGRAM_ID) {
  let toAccount;
  try {
    toAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      tokenMint,
      owner,
      allowOwnerOffCurve,
      tokenProgram
    );
    const account = yield connection.getAccountInfo(toAccount);
    if (!account) {
      const ix = _spltoken.createAssociatedTokenAccountInstruction.call(void 0, 
        payer,
        toAccount,
        owner,
        tokenMint,
        tokenProgram
      );
      return [toAccount, ix];
    }
    return [toAccount, void 0];
  } catch (e) {
    console.error("Error::getOrCreateATAInstruction", e);
    throw e;
  }
});

// src/referral.ts
var useReferral = (connection) => {
  return new ReferralProvider(connection);
};
var ReferralProvider = class {
  constructor(connection) {
    this.connection = connection;
    const provider = new (0, _anchor.AnchorProvider)(
      connection,
      {},
      _anchor.AnchorProvider.defaultOptions()
    );
    this.program = new (0, _anchor.Program)(IDL, PROGRAM_ID, provider);
  }
  getProjects() {
    return __async(this, arguments, function* (filters = []) {
      return yield this.program.account.project.all(filters);
    });
  }
  getProject(pubkey) {
    return __async(this, null, function* () {
      return yield this.program.account.project.fetch(pubkey);
    });
  }
  getReferralAccount(pubkey) {
    return __async(this, null, function* () {
      return yield this.program.account.referralAccount.fetch(pubkey);
    });
  }
  getReferralAccounts() {
    return __async(this, arguments, function* (filters = []) {
      return yield this.program.account.referralAccount.all(filters);
    });
  }
  getProjectAuthorityPubKey(project) {
    let [projectAuthority] = _web3js.PublicKey.findProgramAddressSync(
      [Buffer.from("project_authority"), project.base.toBuffer()],
      this.program.programId
    );
    return projectAuthority;
  }
  getReferralAccountWithNamePubKey({
    projectPubKey,
    name
  }) {
    const [referralAccountPubKey] = _web3js.PublicKey.findProgramAddressSync(
      [Buffer.from("referral"), projectPubKey.toBuffer(), Buffer.from(name)],
      this.program.programId
    );
    return referralAccountPubKey;
  }
  getReferralTokenAccountPubKey({
    referralAccountPubKey,
    mint
  }) {
    const [referralTokenAccountPubKey] = _web3js.PublicKey.findProgramAddressSync(
      [
        Buffer.from("referral_ata"),
        referralAccountPubKey.toBuffer(),
        mint.toBuffer()
      ],
      this.program.programId
    );
    return referralTokenAccountPubKey;
  }
  getReferralTokenAccountPubKeyV2({
    referralAccountPubKey,
    tokenProgramId,
    mint
  }) {
    const tokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
      mint,
      referralAccountPubKey,
      true,
      tokenProgramId
    );
    return tokenAccount;
  }
  getReferralTokenAccounts(referralAccountAddress) {
    return __async(this, null, function* () {
      const referralAccount = yield this.program.account.referralAccount.fetch(
        new (0, _web3js.PublicKey)(referralAccountAddress)
      );
      const [tokenAccounts, token2022Accounts] = yield Promise.all(
        [_spltoken.TOKEN_PROGRAM_ID, _spltoken.TOKEN_2022_PROGRAM_ID].map((programId) => __async(this, null, function* () {
          const mintSet = /* @__PURE__ */ new Set();
          const possibleTokenAccountSet = /* @__PURE__ */ new Set();
          const tokenAccountMap = /* @__PURE__ */ new Map();
          const allTokenAccounts = yield this.connection.getTokenAccountsByOwner(
            referralAccount.project,
            { programId }
          );
          allTokenAccounts.value.map((tokenAccount) => {
            const accountData = _spltoken.AccountLayout.decode(
              new Uint8Array(tokenAccount.account.data)
            );
            if (!mintSet.has(accountData.mint.toBase58())) {
              const address = this.getReferralTokenAccountPubKey({
                referralAccountPubKey: new (0, _web3js.PublicKey)(referralAccountAddress),
                mint: accountData.mint
              });
              mintSet.add(accountData.mint.toBase58());
              possibleTokenAccountSet.add(address.toBase58());
            }
            tokenAccountMap.set(tokenAccount.pubkey.toBase58(), accountData);
          });
          return Array.from(possibleTokenAccountSet).reduce((acc, address) => {
            const tokenAccount = tokenAccountMap.get(address);
            if (tokenAccount) {
              acc.push({ pubkey: new (0, _web3js.PublicKey)(address), account: tokenAccount });
            }
            return acc;
          }, new Array());
        }))
      );
      return { tokenAccounts, token2022Accounts };
    });
  }
  getReferralTokenAccountsV2(referralAccountAddress) {
    return __async(this, null, function* () {
      const [tokenAccounts, token2022Accounts] = yield Promise.all(
        [_spltoken.TOKEN_PROGRAM_ID, _spltoken.TOKEN_2022_PROGRAM_ID].map((programId) => __async(this, null, function* () {
          const allTokenAccounts = yield this.connection.getTokenAccountsByOwner(
            new (0, _web3js.PublicKey)(referralAccountAddress),
            { programId }
          );
          return allTokenAccounts.value.map((tokenAccount) => ({
            pubkey: tokenAccount.pubkey,
            account: _spltoken.AccountLayout.decode(
              new Uint8Array(tokenAccount.account.data)
            )
          }));
        }))
      );
      return { tokenAccounts, token2022Accounts };
    });
  }
  getReferralTokenAccountsWithStrategy(_0) {
    return __async(this, arguments, function* (referralAccountAddress, strategy = {
      type: "top-tokens",
      topN: 100
    }) {
      const tokens = yield (() => __async(this, null, function* () {
        if (strategy.type === "top-tokens") {
          const topTokens = (yield (yield fetch("https://lite-api.jup.ag/tokens/v2/toptraded/24h")).json()).slice(0, strategy.topN);
          return topTokens;
        } else if (strategy.type === "token-list") {
          const [verifiedTokens, lstTokens] = yield Promise.all([
            fetch("https://lite-api.jup.ag/tokens/v2/tag?query=verified").then(
              (res) => res.json()
            ),
            fetch("https://lite-api.jup.ag/tokens/v2/tag?query=lst").then(
              (res) => res.json()
            )
          ]);
          const tokens2 = Array.from(
            /* @__PURE__ */ new Set([
              ...verifiedTokens.map(({ id }) => id),
              ...lstTokens.map(({ id }) => id)
            ])
          );
          return tokens2;
        } else {
          throw new Error("Invalid strategy");
        }
      }))();
      const tokensWithOwner = yield chunkedGetMultipleAccountInfos(
        this.connection,
        tokens.map((topToken) => new (0, _web3js.PublicKey)(topToken))
      );
      const mintOwnerMap = /* @__PURE__ */ new Map();
      tokens.forEach((token, index) => {
        const accountInfo = tokensWithOwner[index];
        if (accountInfo) {
          mintOwnerMap.set(token, accountInfo.owner);
        }
      });
      const referralTokenAccounts = tokens.map(
        (topToken) => this.getReferralTokenAccountPubKey({
          referralAccountPubKey: new (0, _web3js.PublicKey)(referralAccountAddress),
          mint: new (0, _web3js.PublicKey)(topToken)
        })
      );
      const tokenAccounts = [];
      const token2022Accounts = [];
      const accountInfos = yield chunkedGetMultipleAccountInfos(
        this.connection,
        referralTokenAccounts
      );
      for (const [index, accountInfo] of accountInfos.entries()) {
        if (!accountInfo)
          continue;
        const address = referralTokenAccounts[index];
        const rawAccount = _spltoken.AccountLayout.decode(new Uint8Array(accountInfo.data));
        const rawAccountWithPubkey = {
          pubkey: address,
          account: rawAccount
        };
        if (accountInfo.owner.equals(_spltoken.TOKEN_PROGRAM_ID)) {
          tokenAccounts.push(rawAccountWithPubkey);
        } else if (accountInfo.owner.equals(_spltoken.TOKEN_2022_PROGRAM_ID)) {
          token2022Accounts.push(rawAccountWithPubkey);
        }
      }
      return {
        tokenAccounts,
        token2022Accounts
      };
    });
  }
  getReferralTokenAccountsWithStrategyV2(_0) {
    return __async(this, arguments, function* (referralAccountAddress, strategy = {
      type: "top-tokens",
      topN: 100
    }) {
      const tokens = yield (() => __async(this, null, function* () {
        if (strategy.type === "top-tokens") {
          const topTokens = (yield (yield fetch("https://lite-api.jup.ag/tokens/v2/toptraded/24h")).json()).slice(0, strategy.topN);
          return topTokens;
        } else if (strategy.type === "token-list") {
          const [verifiedTokens, lstTokens] = yield Promise.all([
            fetch("https://lite-api.jup.ag/tokens/v2/tag?query=verified").then(
              (res) => res.json()
            ),
            fetch("https://lite-api.jup.ag/tokens/v2/tag?query=lst").then(
              (res) => res.json()
            )
          ]);
          const tokens2 = Array.from(
            /* @__PURE__ */ new Set([
              ...verifiedTokens.map(({ id }) => id),
              ...lstTokens.map(({ id }) => id)
            ])
          );
          return tokens2;
        } else {
          throw new Error("Invalid strategy");
        }
      }))();
      const referralPubkey = new (0, _web3js.PublicKey)(referralAccountAddress);
      const [tokenAccounts, token2022Accounts] = yield Promise.all(
        [_spltoken.TOKEN_PROGRAM_ID, _spltoken.TOKEN_2022_PROGRAM_ID].map((programId) => __async(this, null, function* () {
          const accounts = yield this.connection.getTokenAccountsByOwner(
            referralPubkey,
            { programId }
          );
          return accounts.value.map((tokenAccount) => ({
            pubkey: tokenAccount.pubkey,
            account: _spltoken.AccountLayout.decode(
              new Uint8Array(tokenAccount.account.data)
            )
          })).filter(
            (account) => (
              // Only include accounts for mints in our strategy list
              tokens.includes(account.account.mint.toBase58())
            )
          );
        }))
      );
      return {
        tokenAccounts,
        token2022Accounts
      };
    });
  }
  initializeProject(_0) {
    return __async(this, arguments, function* ({
      basePubKey,
      adminPubKey,
      name,
      defaultShareBps
    }) {
      const [projectPubKey] = _web3js.PublicKey.findProgramAddressSync(
        [Buffer.from("project"), basePubKey.toBuffer()],
        this.program.programId
      );
      return yield this.program.methods.initializeProject({ name, defaultShareBps }).accounts({
        admin: adminPubKey,
        project: projectPubKey,
        base: basePubKey
      }).transaction();
    });
  }
  transferProject(_0) {
    return __async(this, arguments, function* ({
      newAdminPubKey,
      projectPubKey
    }) {
      const project = yield this.program.account.project.fetch(projectPubKey);
      return yield this.program.methods.transferProject({}).accounts({
        admin: project.admin,
        project: projectPubKey,
        newAdmin: newAdminPubKey
      }).transaction();
    });
  }
  initializeReferralAccount(_0) {
    return __async(this, arguments, function* ({
      projectPubKey,
      partnerPubKey,
      payerPubKey,
      referralAccountPubKey
    }) {
      return yield this.program.methods.initializeReferralAccount({}).accounts({
        project: projectPubKey,
        partner: partnerPubKey,
        referralAccount: referralAccountPubKey,
        payer: payerPubKey
      }).transaction();
    });
  }
  initializeReferralAccountWithName(_0) {
    return __async(this, arguments, function* ({
      projectPubKey,
      partnerPubKey,
      payerPubKey,
      name
    }) {
      const referralAccountPubKey = this.getReferralAccountWithNamePubKey({
        projectPubKey,
        name
      });
      const tx = yield this.program.methods.initializeReferralAccountWithName({ name }).accounts({
        project: projectPubKey,
        partner: partnerPubKey,
        referralAccount: referralAccountPubKey,
        payer: payerPubKey
      }).transaction();
      return { tx, referralAccountPubKey };
    });
  }
  transferReferralAccount(_0) {
    return __async(this, arguments, function* ({
      newPartnerPubKey,
      referralAccountPubKey
    }) {
      const referralAccount = yield this.program.account.referralAccount.fetch(
        referralAccountPubKey
      );
      return yield this.program.methods.transferReferralAccount({}).accounts({
        partner: referralAccount.partner,
        newPartner: newPartnerPubKey,
        referralAccount: referralAccountPubKey
      }).transaction();
    });
  }
  initializeReferralTokenAccount(_0) {
    return __async(this, arguments, function* ({
      payerPubKey,
      referralAccountPubKey,
      mint
    }) {
      const mintAccount = yield this.connection.getAccountInfo(mint);
      if (!mintAccount)
        throw new Error("Invalid mint");
      if (![_spltoken.TOKEN_PROGRAM_ID, _spltoken.TOKEN_2022_PROGRAM_ID].some(
        (id) => id.equals(mintAccount.owner)
      ))
        throw new Error("Invalid mint");
      const referralAccount = yield this.program.account.referralAccount.fetch(
        referralAccountPubKey
      );
      const referralTokenAccountPubKey = this.getReferralTokenAccountPubKey({
        referralAccountPubKey,
        mint
      });
      const tx = yield this.program.methods.initializeReferralTokenAccount().accounts({
        payer: payerPubKey,
        project: referralAccount.project,
        referralAccount: referralAccountPubKey,
        referralTokenAccount: referralTokenAccountPubKey,
        mint,
        tokenProgram: mintAccount.owner
      }).transaction();
      return { tx, referralTokenAccountPubKey };
    });
  }
  initializeReferralTokenAccountV2(_0) {
    return __async(this, arguments, function* ({
      payerPubKey,
      referralAccountPubKey,
      mint
    }) {
      const mintAccount = yield this.connection.getAccountInfo(mint);
      if (!mintAccount)
        throw new Error("Invalid mint");
      if (![_spltoken.TOKEN_PROGRAM_ID, _spltoken.TOKEN_2022_PROGRAM_ID].some(
        (id) => id.equals(mintAccount.owner)
      ))
        throw new Error("Invalid mint");
      const tokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
        mint,
        referralAccountPubKey,
        true,
        mintAccount.owner
      );
      const ix = _spltoken.createAssociatedTokenAccountIdempotentInstruction.call(void 0, 
        payerPubKey,
        tokenAccount,
        referralAccountPubKey,
        mint,
        mintAccount.owner
      );
      const tx = new (0, _web3js.Transaction)().add(ix);
      return { tx, tokenAccount };
    });
  }
  claim(_0) {
    return __async(this, arguments, function* ({
      payerPubKey,
      referralAccountPubKey,
      mint
    }) {
      const mintAccount = yield this.connection.getAccountInfo(mint);
      if (!mintAccount)
        throw new Error("Invalid mint");
      if (![_spltoken.TOKEN_PROGRAM_ID, _spltoken.TOKEN_2022_PROGRAM_ID].some(
        (id) => id.equals(mintAccount.owner)
      ))
        throw new Error("Invalid mint");
      const referralAccount = yield this.program.account.referralAccount.fetch(
        referralAccountPubKey
      );
      const project = yield this.program.account.project.fetch(
        referralAccount.project
      );
      const [
        referralTokenAccountPubKey,
        [partnerTokenAccount, createPartnerTokenAccountIx],
        [projectAdminTokenAccount, createProjectAdminTokenAccountIx]
      ] = yield Promise.all([
        this.getReferralTokenAccountPubKey({
          referralAccountPubKey,
          mint
        }),
        getOrCreateATAInstruction(
          mint,
          referralAccount.partner,
          this.connection,
          payerPubKey,
          void 0,
          mintAccount.owner
        ),
        getOrCreateATAInstruction(
          mint,
          project.admin,
          this.connection,
          payerPubKey,
          void 0,
          mintAccount.owner
        )
      ]);
      let preInstructions = [];
      if (createPartnerTokenAccountIx)
        preInstructions.push(createPartnerTokenAccountIx);
      if (createProjectAdminTokenAccountIx) {
        const projectAuthority = this.getProjectAuthorityPubKey(project);
        const ix = yield this.program.methods.createAdminTokenAccount().accounts({
          project: referralAccount.project,
          projectAuthority,
          admin: project.admin,
          projectAdminTokenAccount,
          mint,
          tokenProgram: mintAccount.owner
        }).instruction();
        preInstructions.push(ix);
      }
      const transaction = yield this.program.methods.claim().accounts({
        payer: payerPubKey,
        project: referralAccount.project,
        admin: project.admin,
        projectAdminTokenAccount,
        referralAccount: referralAccountPubKey,
        referralTokenAccount: referralTokenAccountPubKey,
        partner: referralAccount.partner,
        partnerTokenAccount,
        mint,
        tokenProgram: mintAccount.owner
      }).preInstructions(preInstructions).transaction();
      const instructions = transaction.instructions;
      const addressLookupTable = yield this.connection.getAddressLookupTable(
        new (0, _web3js.PublicKey)("GBzQG2iFrPwXjGtCnwNt9S5eHd8xAR8jUMt3QDJpnjud")
      );
      const lookupTableAccount = addressLookupTable.value;
      const { units, microLamports } = yield feeService.getOptimalComputeUnitLimitAndPrice({
        instructions: transaction.instructions,
        payer: payerPubKey,
        lookupTables: [lookupTableAccount]
      });
      instructions.unshift(
        _web3js.ComputeBudgetProgram.setComputeUnitPrice({ microLamports })
      );
      if (units) {
        instructions.unshift(_web3js.ComputeBudgetProgram.setComputeUnitLimit({ units }));
      }
      const blockhash = (yield this.connection.getLatestBlockhash()).blockhash;
      const messageV0 = new (0, _web3js.TransactionMessage)({
        payerKey: payerPubKey,
        instructions,
        recentBlockhash: blockhash
      }).compileToV0Message();
      return new (0, _web3js.VersionedTransaction)(messageV0);
    });
  }
  claimV2(_0) {
    return __async(this, arguments, function* ({
      payerPubKey,
      referralAccountPubKey,
      mint
    }) {
      const mintAccount = yield this.connection.getAccountInfo(mint);
      if (!mintAccount)
        throw new Error("Invalid mint");
      if (![_spltoken.TOKEN_PROGRAM_ID, _spltoken.TOKEN_2022_PROGRAM_ID].some(
        (id) => id.equals(mintAccount.owner)
      ))
        throw new Error("Invalid mint");
      const referralAccount = yield this.program.account.referralAccount.fetch(
        referralAccountPubKey
      );
      const project = yield this.program.account.project.fetch(
        referralAccount.project
      );
      const [
        referralTokenAccountPubKey,
        [partnerTokenAccount, createPartnerTokenAccountIx],
        [projectAdminTokenAccount, createProjectAdminTokenAccountIx]
      ] = yield Promise.all([
        this.getReferralTokenAccountPubKeyV2({
          referralAccountPubKey,
          mint,
          tokenProgramId: mintAccount.owner
        }),
        getOrCreateATAInstruction(
          mint,
          referralAccount.partner,
          this.connection,
          payerPubKey,
          void 0,
          mintAccount.owner
        ),
        getOrCreateATAInstruction(
          mint,
          project.admin,
          this.connection,
          payerPubKey,
          void 0,
          mintAccount.owner
        )
      ]);
      let preInstructions = [];
      if (createPartnerTokenAccountIx)
        preInstructions.push(createPartnerTokenAccountIx);
      if (createProjectAdminTokenAccountIx) {
        const projectAuthority = this.getProjectAuthorityPubKey(project);
        const ix = yield this.program.methods.createAdminTokenAccount().accounts({
          project: referralAccount.project,
          projectAuthority,
          admin: project.admin,
          projectAdminTokenAccount,
          mint,
          tokenProgram: mintAccount.owner
        }).instruction();
        preInstructions.push(ix);
      }
      const transaction = yield this.program.methods.claimV2().accountsStrict({
        payer: payerPubKey,
        project: referralAccount.project,
        admin: project.admin,
        projectAdminTokenAccount,
        referralAccount: referralAccountPubKey,
        referralTokenAccount: referralTokenAccountPubKey,
        partner: referralAccount.partner,
        partnerTokenAccount,
        mint,
        tokenProgram: mintAccount.owner,
        systemProgram: _web3js.SystemProgram.programId,
        associatedTokenProgram: _spltoken.ASSOCIATED_TOKEN_PROGRAM_ID
      }).preInstructions(preInstructions).transaction();
      const instructions = transaction.instructions;
      const addressLookupTable = yield this.connection.getAddressLookupTable(
        new (0, _web3js.PublicKey)("GBzQG2iFrPwXjGtCnwNt9S5eHd8xAR8jUMt3QDJpnjud")
      );
      const lookupTableAccount = addressLookupTable.value;
      const { units, microLamports } = yield feeService.getOptimalComputeUnitLimitAndPrice({
        instructions: transaction.instructions,
        payer: payerPubKey,
        lookupTables: [lookupTableAccount]
      });
      instructions.unshift(
        _web3js.ComputeBudgetProgram.setComputeUnitPrice({ microLamports })
      );
      if (units) {
        instructions.unshift(_web3js.ComputeBudgetProgram.setComputeUnitLimit({ units }));
      }
      const blockhash = (yield this.connection.getLatestBlockhash()).blockhash;
      const messageV0 = new (0, _web3js.TransactionMessage)({
        payerKey: payerPubKey,
        instructions,
        recentBlockhash: blockhash
      }).compileToV0Message();
      return new (0, _web3js.VersionedTransaction)(messageV0);
    });
  }
  claimAll(_0) {
    return __async(this, arguments, function* ({
      payerPubKey,
      referralAccountPubKey,
      strategy
    }) {
      const blockhash = (yield this.connection.getLatestBlockhash()).blockhash;
      const lookupTableAccount = yield this.connection.getAddressLookupTable(
        new (0, _web3js.PublicKey)("GBzQG2iFrPwXjGtCnwNt9S5eHd8xAR8jUMt3QDJpnjud")
      ).then((res) => res.value);
      const referralAccount = yield this.program.account.referralAccount.fetch(
        referralAccountPubKey
      );
      const project = yield this.program.account.project.fetch(
        referralAccount.project
      );
      const projectAuthority = this.getProjectAuthorityPubKey(project);
      const { tokenAccounts, token2022Accounts } = strategy ? yield this.getReferralTokenAccountsWithStrategy(
        referralAccountPubKey.toString(),
        strategy
      ) : yield this.getReferralTokenAccounts(referralAccountPubKey.toString());
      const vtTxs = yield Promise.all(
        [tokenAccounts, token2022Accounts].map((accounts, idx) => __async(this, null, function* () {
          const tokenProgramId = idx === 0 ? _spltoken.TOKEN_PROGRAM_ID : _spltoken.TOKEN_2022_PROGRAM_ID;
          const tokensWithAmount = accounts.filter(
            (item) => item.account.amount > 0 && item.account.state === 1
          );
          const claimParams = yield Promise.all(
            tokensWithAmount.map((token) => __async(this, null, function* () {
              const referralTokenAccountPubKey = this.getReferralTokenAccountPubKey({
                referralAccountPubKey,
                mint: token.account.mint
              });
              const preInstructions = [];
              const partnerTokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
                token.account.mint,
                referralAccount.partner,
                true,
                tokenProgramId
              );
              preInstructions.push(
                _spltoken.createAssociatedTokenAccountIdempotentInstruction.call(void 0, 
                  payerPubKey,
                  partnerTokenAccount,
                  referralAccount.partner,
                  token.account.mint,
                  tokenProgramId
                )
              );
              const projectAdminTokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
                token.account.mint,
                project.admin,
                true,
                tokenProgramId
              );
              const ix = yield this.program.methods.createAdminTokenAccount().accounts({
                project: referralAccount.project,
                projectAuthority,
                admin: project.admin,
                projectAdminTokenAccount,
                mint: token.account.mint,
                tokenProgram: tokenProgramId
              }).instruction();
              preInstructions.push(ix);
              return {
                referralTokenAccountPubKey,
                projectAdminTokenAccount,
                partnerTokenAccount,
                preInstructions,
                mint: token.account.mint
              };
            }))
          );
          const txs = [];
          let instructions = [];
          let chunk2 = 0;
          for (const {
            referralTokenAccountPubKey,
            projectAdminTokenAccount,
            partnerTokenAccount,
            mint,
            preInstructions
          } of claimParams) {
            const tx = yield this.program.methods.claim().accounts({
              payer: payerPubKey,
              project: referralAccount.project,
              admin: project.admin,
              projectAdminTokenAccount,
              referralAccount: referralAccountPubKey,
              referralTokenAccount: referralTokenAccountPubKey,
              partner: referralAccount.partner,
              partnerTokenAccount,
              mint,
              tokenProgram: tokenProgramId
            }).preInstructions(preInstructions).transaction();
            instructions.push(...tx.instructions);
            chunk2 += 1;
            if (chunk2 === 4) {
              const { units, microLamports } = yield feeService.getOptimalComputeUnitLimitAndPrice({
                instructions,
                payer: payerPubKey,
                lookupTables: [lookupTableAccount]
              });
              instructions.unshift(
                _web3js.ComputeBudgetProgram.setComputeUnitPrice({ microLamports })
              );
              if (units) {
                instructions.unshift(
                  _web3js.ComputeBudgetProgram.setComputeUnitLimit({ units })
                );
              }
              const messageV0 = new (0, _web3js.TransactionMessage)({
                payerKey: payerPubKey,
                instructions,
                recentBlockhash: blockhash
              }).compileToV0Message([lookupTableAccount]);
              chunk2 = 0;
              instructions = [];
              txs.push(new (0, _web3js.VersionedTransaction)(messageV0));
            }
          }
          return txs;
        }))
      );
      return vtTxs.flat();
    });
  }
  claimAllV2(_0) {
    return __async(this, arguments, function* ({
      payerPubKey,
      referralAccountPubKey
    }) {
      const blockhash = (yield this.connection.getLatestBlockhash()).blockhash;
      const lookupTableAccount = yield this.connection.getAddressLookupTable(
        new (0, _web3js.PublicKey)("GBzQG2iFrPwXjGtCnwNt9S5eHd8xAR8jUMt3QDJpnjud")
      ).then((res) => res.value);
      const referralAccount = yield this.program.account.referralAccount.fetch(
        referralAccountPubKey
      );
      const project = yield this.program.account.project.fetch(
        referralAccount.project
      );
      const projectAuthority = this.getProjectAuthorityPubKey(project);
      const { tokenAccounts, token2022Accounts } = yield this.getReferralTokenAccountsV2(referralAccountPubKey.toString());
      const vtTxs = yield Promise.all(
        [tokenAccounts, token2022Accounts].map((accounts, idx) => __async(this, null, function* () {
          const tokenProgramId = idx === 0 ? _spltoken.TOKEN_PROGRAM_ID : _spltoken.TOKEN_2022_PROGRAM_ID;
          const tokensWithAmount = accounts.filter(
            (item) => item.account.amount > 0 && item.account.state === 1
          );
          const claimParams = yield Promise.all(
            tokensWithAmount.map((token) => __async(this, null, function* () {
              const preInstructions = [];
              const partnerTokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
                token.account.mint,
                referralAccount.partner,
                true,
                tokenProgramId
              );
              preInstructions.push(
                _spltoken.createAssociatedTokenAccountIdempotentInstruction.call(void 0, 
                  payerPubKey,
                  partnerTokenAccount,
                  referralAccount.partner,
                  token.account.mint,
                  tokenProgramId
                )
              );
              const projectAdminTokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
                token.account.mint,
                project.admin,
                true,
                tokenProgramId
              );
              const ix = yield this.program.methods.createAdminTokenAccount().accounts({
                project: referralAccount.project,
                projectAuthority,
                admin: project.admin,
                projectAdminTokenAccount,
                mint: token.account.mint,
                tokenProgram: tokenProgramId
              }).instruction();
              preInstructions.push(ix);
              return {
                projectAdminTokenAccount,
                partnerTokenAccount,
                preInstructions,
                mint: token.account.mint,
                referralTokenAccount: token.pubkey
                // Use ATA directly
              };
            }))
          );
          const txs = [];
          let instructions = [];
          let chunk2 = 0;
          for (const {
            projectAdminTokenAccount,
            partnerTokenAccount,
            mint,
            preInstructions,
            referralTokenAccount
          } of claimParams) {
            const tx = yield this.program.methods.claimV2().accounts({
              payer: payerPubKey,
              project: referralAccount.project,
              admin: project.admin,
              projectAdminTokenAccount,
              referralAccount: referralAccountPubKey,
              referralTokenAccount,
              partner: referralAccount.partner,
              partnerTokenAccount,
              mint,
              tokenProgram: tokenProgramId,
              systemProgram: _web3js.SystemProgram.programId,
              associatedTokenProgram: _spltoken.ASSOCIATED_TOKEN_PROGRAM_ID
            }).preInstructions(preInstructions).transaction();
            instructions.push(...tx.instructions);
            chunk2 += 1;
            if (chunk2 === 4) {
              const { units, microLamports } = yield feeService.getOptimalComputeUnitLimitAndPrice({
                instructions,
                payer: payerPubKey,
                lookupTables: [lookupTableAccount]
              });
              instructions.unshift(
                _web3js.ComputeBudgetProgram.setComputeUnitPrice({ microLamports })
              );
              if (units) {
                instructions.unshift(
                  _web3js.ComputeBudgetProgram.setComputeUnitLimit({ units })
                );
              }
              const messageV0 = new (0, _web3js.TransactionMessage)({
                payerKey: payerPubKey,
                instructions,
                recentBlockhash: blockhash
              }).compileToV0Message([lookupTableAccount]);
              chunk2 = 0;
              instructions = [];
              txs.push(new (0, _web3js.VersionedTransaction)(messageV0));
            }
          }
          if (instructions.length > 0) {
            const messageV0 = new (0, _web3js.TransactionMessage)({
              payerKey: payerPubKey,
              instructions,
              recentBlockhash: blockhash
            }).compileToV0Message([lookupTableAccount]);
            txs.push(new (0, _web3js.VersionedTransaction)(messageV0));
          }
          return txs;
        }))
      );
      return vtTxs.flat();
    });
  }
  claimPartially(_0) {
    return __async(this, arguments, function* ({
      payerPubKey,
      referralAccountPubKey,
      withdrawalableTokenAddress
    }) {
      const blockhash = (yield this.connection.getLatestBlockhash()).blockhash;
      const lookupTableAccount = yield this.connection.getAddressLookupTable(
        new (0, _web3js.PublicKey)("GBzQG2iFrPwXjGtCnwNt9S5eHd8xAR8jUMt3QDJpnjud")
      ).then((res) => res.value);
      const referralAccount = yield this.program.account.referralAccount.fetch(
        referralAccountPubKey
      );
      const project = yield this.program.account.project.fetch(
        referralAccount.project
      );
      const projectAuthority = this.getProjectAuthorityPubKey(project);
      const result = yield this.connection.getMultipleAccountsInfo(
        withdrawalableTokenAddress
      );
      const claimInstructionParams = yield Promise.all(
        result.map((item) => __async(this, null, function* () {
          const tokenProgramId = item.owner;
          const tokenAccountData = _spltoken.AccountLayout.decode(
            new Uint8Array(item.data)
          );
          const referralTokenAccountPubKey = this.getReferralTokenAccountPubKey({
            referralAccountPubKey,
            mint: tokenAccountData.mint
          });
          const preInstructions = [];
          const partnerTokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
            tokenAccountData.mint,
            referralAccount.partner,
            true,
            tokenProgramId
          );
          preInstructions.push(
            _spltoken.createAssociatedTokenAccountIdempotentInstruction.call(void 0, 
              payerPubKey,
              partnerTokenAccount,
              referralAccount.partner,
              tokenAccountData.mint,
              tokenProgramId
            )
          );
          const projectAdminTokenAccount = _spltoken.getAssociatedTokenAddressSync.call(void 0, 
            tokenAccountData.mint,
            project.admin,
            true,
            tokenProgramId
          );
          const ix = yield this.program.methods.createAdminTokenAccount().accounts({
            project: referralAccount.project,
            projectAuthority,
            admin: project.admin,
            projectAdminTokenAccount,
            mint: tokenAccountData.mint,
            tokenProgram: tokenProgramId
          }).instruction();
          preInstructions.push(ix);
          return {
            referralTokenAccountPubKey,
            projectAdminTokenAccount,
            partnerTokenAccount,
            preInstructions,
            tokenProgramId,
            mint: tokenAccountData.mint
          };
        }))
      );
      const chunkedInstructions = _chunk2.default.call(void 0, claimInstructionParams, 4);
      const txs = yield Promise.all(
        chunkedInstructions.map((chunkParams) => __async(this, null, function* () {
          let instructions = [];
          yield Promise.all(
            chunkParams.map(
              (_02) => __async(this, [_02], function* ({
                referralTokenAccountPubKey,
                projectAdminTokenAccount,
                partnerTokenAccount,
                mint,
                preInstructions,
                tokenProgramId
              }) {
                const tx = yield this.program.methods.claim().accounts({
                  payer: payerPubKey,
                  project: referralAccount.project,
                  admin: project.admin,
                  projectAdminTokenAccount,
                  referralAccount: referralAccountPubKey,
                  referralTokenAccount: referralTokenAccountPubKey,
                  partner: referralAccount.partner,
                  partnerTokenAccount,
                  mint,
                  tokenProgram: tokenProgramId
                }).preInstructions(preInstructions).transaction();
                instructions.push(...tx.instructions);
              })
            )
          );
          const { units, microLamports } = yield feeService.getOptimalComputeUnitLimitAndPrice({
            instructions,
            payer: payerPubKey,
            lookupTables: [lookupTableAccount]
          });
          instructions.unshift(
            _web3js.ComputeBudgetProgram.setComputeUnitPrice({ microLamports })
          );
          if (units) {
            instructions.unshift(
              _web3js.ComputeBudgetProgram.setComputeUnitLimit({ units })
            );
          }
          const messageV0 = new (0, _web3js.TransactionMessage)({
            payerKey: payerPubKey,
            instructions,
            recentBlockhash: blockhash
          }).compileToV0Message([lookupTableAccount]);
          instructions = [];
          return new (0, _web3js.VersionedTransaction)(messageV0);
        }))
      );
      return txs;
    });
  }
};

// src/filter.ts
var projectAdminFilter = (publicKey) => {
  return {
    memcmp: {
      offset: 8 + 32,
      bytes: publicKey.toBase58()
    }
  };
};
var referralAccountPartnerFilter = (publicKey) => {
  return {
    memcmp: {
      offset: 8,
      bytes: publicKey.toBase58()
    }
  };
};
var referralAccountProjectFilter = (publicKey) => {
  return {
    memcmp: {
      offset: 8 + 32,
      bytes: publicKey.toBase58()
    }
  };
};









exports.IDL = IDL; exports.PROGRAM_ID = PROGRAM_ID; exports.RPC_URL = RPC_URL; exports.ReferralProvider = ReferralProvider; exports.projectAdminFilter = projectAdminFilter; exports.referralAccountPartnerFilter = referralAccountPartnerFilter; exports.referralAccountProjectFilter = referralAccountProjectFilter; exports.useReferral = useReferral;
//# sourceMappingURL=index.js.map